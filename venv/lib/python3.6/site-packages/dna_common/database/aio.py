from asyncio import get_event_loop
from concurrent.futures import ThreadPoolExecutor
from functools import partial

from sqlalchemy import create_engine
from typing import NamedTuple, Iterable

from dna_common.app.inspector import Inspectable
from dna_common.config import BaseConfig


PING_COMMAND = 'SELECT 1'


class TableValuedParams(NamedTuple):
    table_type: str
    rows: Iterable
    columns: Iterable

class AioDatabase(Inspectable):

    def __init__(self, url, thread_count=5, loop=None,  **options):
        self._loop = loop
        self.engine = self._build_engine(url, options)
        self.executor = self._build_executor(thread_count)

    def _build_engine(self, url, options):
        return create_engine(url, _coerce_config=True, **options)

    def _build_executor(self, thread_count):
        return ThreadPoolExecutor(thread_count)

    def execute(self, *args, **kwargs):
        return self.run(self._execute, *args, **kwargs)

    async def dispose(self):
        await self.run(self._dispose)
        self.executor.shutdown()

    def run(self, func, *args, **kwargs):
        loop = self._loop or get_event_loop()
        func = func if not kwargs else partial(func, **kwargs)
        return loop.run_in_executor(self.executor, func, self.engine, *args)

    def _execute(self, engine, *args, **kwargs):
        result = engine.execute(*args, **kwargs)
        if result.returns_rows:
            rows = result.fetchall()
            return ResultSet(rows)

    def _dispose(self, engine):
        return engine.dispose()

    async def is_healthy(self):
        try:
            await self.execute(PING_COMMAND)
        except Exception as e:
            return False
        else:
            return True

    async def inspect(self):
        return {
            'engine': str(self.engine),
            'connected': await self.is_healthy()
        }



class ResultSet:

    def __init__(self, rows):
        self._rows = rows

    def all(self, as_dict=False):
        if as_dict:
            return self.as_dict()
        else:
            return self._rows

    def first(self, default=None, as_dict=False):
        if len(self._rows) == 0:
            return default
        if as_dict:
            return {key: value for key, value in self._rows[0].items()} 
        else:
            return self._rows[0]

    def one(self, default=None, as_dict=False):
        if len(self) > 1:
            raise ValueError('More than one row in result set')
        return self.first(default, as_dict)

    def scalar(self, default=None):
        if len(self._rows) == 0:
            return default        
        return self.one()[0]

    def as_dict(self):
        return [{key: value for key, value in row.items()} for row in self]

    def __iter__(self):
        return iter(self._rows)

    def __len__(self):
        return len(self._rows)
