from asyncio import AbstractEventLoop, gather, get_event_loop
from collections import MutableMapping, defaultdict
from cryptography.fernet import Fernet
from enum import Enum
from inspect import getmodulename, isawaitable, stack
from json import load
from logging import DEBUG, INFO, StreamHandler, basicConfig, getLogger
from logging.config import dictConfig
import io
from os import getcwd, path
from signal import SIGTERM, SIGINT
from typing import Type

from dotenv import load_dotenv
from pydantic.exceptions import ConfigError

from dna_common.app.config import AppBaseConfig
from dna_common.app.inspector import Inspectable, create_inspector


ENCR_KEY = '5hXGWoHTtidojW2M4ivhD__Rn3XjZjD7rP2v8fowMQ8='


"""
class App:

    # Event Emitter

    def add_listener(self, event, handler):
        pass

    def emit(self, event, *args, **kwargs):
        pass

    # Run

    async def run_async(self):
        await self.emit('startup')
        await self.emit('run')
        await self.emit('cleanup')

    def run(self, loop: AbstractEventLoop = None):
        loop = loop or get_event_loop()

        for signal in (SIGINT, SIGTERM):
            loop.add_signal_handler(signal, shutdown_handler)

        try:
            loop.run_until_complete(self.run_async())
        except Exception:
            app.logger.error('Exception thrown while running app', exc_info=True)

"""




class App(MutableMapping, Inspectable):

    def __init__(self, config=AppBaseConfig, config_prefix='APP_'):
        self.loop = None
        self.logger = getLogger('app')
        self.listeners = defaultdict(list)
        self._load_dotenv()
        self.config = config(prefix=config_prefix)
        self.state = {}
        self.is_running = False
        self.is_stopping = False
        create_inspector(self)

    def __getitem__(self, key):
        return self.state[key]

    def __setitem__(self, key, value):
        self.state[key] = value

    def __delitem__(self, key):
        del self.state[key]

    def __iter__(self):
        return iter(self.state)

    def __len__(self):
        return len(self.state)

    def _load_dotenv(self):
        cwd = getcwd()
        filepath = path.join(cwd, '.env')
        if path.exists(filepath):
            self.logger.info('Loading dotenv from %s', filepath)
            load_dotenv(filepath)

    ''' implementation for when we're ready to encrypt app config:
    def _load_dotenv(self):
        cwd = getcwd()
        filepath = path.join(cwd, '.env')
        if path.exists(filepath):
            self.logger.info('Loading dotenv from %s', filepath)
            with open(filepath, 'rb') as file:
                app_config_encr = file.read()
            cipher_suite = Fernet(ENCR_KEY.encode())
            app_config = cipher_suite.decrypt(
                app_config_encr).decode()
            app_config = io.StringIO(app_config)
            load_dotenv(stream=app_config)
    '''

    def add_listener(self, event, handler):
        self.logger.debug('Adding listener %s for <%s> event', handler, event)
        self.listeners[event].append(handler)

    def on(self, event):
        def decorator(func):
            self.add_listener(event, func)
            return func
        return decorator

    async def emit(self, event, *args, **kwargs):
        self.logger.debug('Event <%s> emitted to %s listeners',
                          event, len(self.listeners[event]))
        awaitables = []
        for handler in self.listeners[event]:
            rv = handler(*args, **kwargs)
            if isawaitable(rv):
                awaitables.append(rv)
        await gather(*awaitables)

    async def setup(self):
        await self.emit('startup', self)

    async def cleanup(self):
        await self.emit('cleanup', self)

    async def start(self, loop):
        self.logger.info('App starting')
        self.loop = loop
        try:
            await self.setup()
            self.is_running = True
            self.loop.create_task(self.emit('start', self))
            await self._run()
            await self.cleanup()
        except Exception as e:
            raise e
        finally:
            self.logger.info('App stopped')
            self.is_running = False
            self.is_stopping = False

    async def stop(self):
        self.logger.info('App stopping')
        self.is_running = False
        self.is_stopping = True
        rv = self._stop()
        if isawaitable(rv):
            await rv

    async def _run(self):
        pass

    def _stop(self):
        pass

    def is_healthy(self):
        if not self.is_running:
            return False

        return True

    async def is_db_connected(self):
        # Get DB obj if exists
        # If DB obj is not found then return "NA" - NotApplicable
        # If DB obj exists then check the health status and returns True/False
        db_obj = self.state.get('database')
        if not db_obj:
            return 'NA'
        else:
            return await db_obj.is_healthy()

    async def inspect(self):
        resources = {}

        for name, instance in self.state.items():
            if isinstance(instance, Inspectable):
                resources[name] = await instance.inspect()

        return {
            'name': self.config.app_name,
            'version': self.config.app_version,
            'running': self.is_running,
            'healthy': self.is_healthy(),
            'resources': resources
        }

    def run(self, **kwargs):
        run_app(self, **kwargs)

    def __repr__(self):
        return f'<{self.__class__.__name__}>'


def run_app(app, loop=None, force_shutdown_delay=5.0):
    loop = loop or get_event_loop()

    def shutdown_handler():
        rv = app.stop()
        if isawaitable(rv):
            loop.create_task(rv)
        loop.call_later(force_shutdown_delay, loop.stop)

    for signal in (SIGINT, SIGTERM):
        loop.add_signal_handler(signal, shutdown_handler)

    start_coro = app.start(loop)
    try:
        loop.run_until_complete(start_coro)
    except Exception:
        app.logger.error('Exception thrown while running app', exc_info=True)
