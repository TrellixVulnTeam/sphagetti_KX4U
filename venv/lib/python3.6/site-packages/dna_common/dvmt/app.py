from asyncio import Future, sleep
from functools import wraps
import logging
import os
from ssl import SSLContext
from urllib.parse import urlsplit
from cryptography.fernet import Fernet

from autobahn.asyncio.component import Component
from autobahn.asyncio.wamp import ApplicationRunner, ApplicationSession, Session
from autobahn.wamp.auth import create_authenticator
from autobahn.wamp.component import _run
from autobahn.wamp.exception import Error, ApplicationError, SessionNotReady
from autobahn.wamp.types import ComponentConfig, RegisterOptions, SubscribeOptions
import txaio
import requests

from dna_common.app.app import App
from dna_common.app.config import AppBaseConfig

class DvmtAppBaseConfig(AppBaseConfig):

    """
    config vars, defined in app .env or 
    dynamically put in by dvmt_auth module
    dvmt_auth_method                <- ticket
    dvmt_auth_id                    <- system name     
    dvmt_auth_ticket                <- token value generated by token generator.
    dvmt_url                        <- crossbar router value.
    dvmt_cert                       <- certificate file required to establsih connection.
    dvmt_generate_token_url         <- API end point for retreiving generated tokens.
    dvmt_realm                      <- crossbar realm
    dvmt_max_retries                <- max number of unsuccessfull retries before app shutdown.
    dvmt_max_retry_delay            <- max delay in seconds between each retries.
    dvmt_initial_retry_delay        <- delay between first failure and first retry.
    dvmt_retry_delay_growth         <- retry backoff factor.
    dvmt_retry_delay_jitter         <- max wait random amount of time before making or retrying a request.
    dvmt_exit_on_session_disconnect <- enables/disables graceful exit.
    """
    dvmt_url: str = ''
    dvmt_cert: str = None
    dvmt_realm: str = 'realm1'
    dvmt_auth_method: str = None
    dvmt_auth_id: str = None 
    dvmt_auth_ticket: str = ''
    dvmt_generate_token_url: str = ''
    dvmt_max_retries: int = 10
    dvmt_serializers: list = ['msgpack', 'json']
    dvmt_max_retry_delay: int = 30
    dvmt_initial_retry_delay: float = 0.5
    dvmt_retry_delay_growth: float = 1.1
    dvmt_retry_delay_jitter: float = 0.1
    dvmt_exit_on_session_disconnect: bool = True


class DvmtApp(App):

    def __init__(self, config=DvmtAppBaseConfig):
        super().__init__(config)
        self.session = None

    def decrypter(self, f_key):
        f = Fernet(f_key.encode('ascii'))
        for enc_variable in self.config.var_key_list:
            if hasattr(self.config, enc_variable):
                setattr(self.config, enc_variable, f.decrypt(getattr(self.config, enc_variable).encode('ascii')).decode('ascii'))
    
    def add_registration(self, procedure, endpoint, **options):
        def on_connect(session):
            return session.register(procedure, endpoint, **options)
        self.add_listener('connect', on_connect)

    def add_subscription(self, topic, handler, **options):
        def on_connect(session):
            return session.subscribe(topic, handler, **options)
        self.add_listener('connect', on_connect)

    def register(self, procedure, **options):
        def decorator(func):
            self.add_registration(procedure, func, **options)
            return func
        return decorator

    def subscribe(self, topic, **options):
        def decorator(func):
            self.add_subscription(topic, func, **options)
            return func
        return decorator

    async def _run(self):
        if self.config.dvmt_cert:
            ssl = SSLContext()
            ssl.load_cert_chain(self.config.dvmt_cert)
        else:
            ssl = False

        urlparts = urlsplit(self.config.dvmt_url)

        transport = {
            'type': 'websocket',
            'url': self.config.dvmt_url,
            'endpoint': {
                'type': 'tcp',
                'host': urlparts.hostname,
                'port': urlparts.port or (urlparts.scheme == 'wss' and 443) or 80,
                'tls': ssl
            },
            'max_retries': self.config.dvmt_max_retries,
            'max_retry_delay': self.config.dvmt_max_retry_delay,
            'initial_retry_delay': self.config.dvmt_initial_retry_delay,
            'retry_delay_growth': self.config.dvmt_retry_delay_growth,
            'retry_delay_jitter': self.config.dvmt_retry_delay_jitter,
            'serializers': self.config.dvmt_serializers
        }

        auth = {}

        if self.config.dvmt_auth_method == 'ticket':
            try:
                dvmt_auth_ticket = requests.get(f'{self.config.dvmt_generate_token_url}{self.config.dvmt_auth_id}', verify=False).text
                auth['ticket'] = {
                    'authid': self.config.dvmt_auth_id,
                    'ticket': dvmt_auth_ticket
                }
            except Exception as e:
                self.logger.error(f'Failed to generate Token - {e}')

        def create_session(config):
            self.session = DvmtAppSession(config, self)
            return self.session

        component = Component(
            transports=transport,
            realm=self.config.dvmt_realm,
            authentication=auth,
            session_factory=create_session
        )

        def done_callback(loop, arg):
            pass

        await _run(self.loop, component, done_callback)


    async def _stop(self):
        if self.session and self.session.is_connected():
            await self.session.leave()

    def is_healthy(self):
        if not self.session:
            return False
        if not self.session.is_attached():
            return False
        return super().is_healthy()

    async def inspect(self):
        details = await super().inspect()
        details['dvmt'] = {
            'connected': self.session and self.session.is_attached()
        }
        if self.session:
            details['dvmt']['registrations'] = [
                {
                    'id': reg.id,
                    'active': reg.active,
                    'procedure': reg.procedure
                }
                for reg
                in self.session._registrations.values()
            ]
            details['dvmt']['subscriptions'] = [
                {
                    'id': reg.id,
                    'active': reg.active,
                    'topic': reg.topic
                }
                for reg
                in self.session._subscriptions.values()
            ]
        return details


class DvmtAppSession(Session):

    def __init__(self, config, app):
        super().__init__(config)
        self.app = app
        self.router = None
        self.id = None
        self.joined = Future()
        self.disconnected = Future()

    async def register(self, procedure, endpoint, **kwargs):
        options = RegisterOptions(**kwargs) if kwargs else None

        @wraps(endpoint)
        def invoke(*args, **kwargs):
            self.app.logger.debug('Invoking <%s> endpoint', procedure)
            try:
                return endpoint(self, *args, **kwargs)
            except ApplicationError as e:
                raise e
            except Exception as e:
                self.app.logger.warning('Exception in <%s> endpoint thrown', procedure, exc_info=True)
                raise e

        self.app.logger.debug('Registering <%s> with %s', procedure, endpoint)

        try:
            registration = await ApplicationSession.register(self, invoke, procedure, options=options)
        except Error as exception:
            self.app.logger.error('Failed to register <%s> with error %s', procedure, exception)
            raise exception

        self.app.logger.info('Registered <%s> with id <%s>', procedure, registration.id)

        return registration

    async def subscribe(self, topic, handler, **kwargs):
        options = SubscribeOptions(**kwargs) if kwargs else None

        @wraps(handler)
        def invoke(*args, **kwargs):
            self.app.logger.debug('Invoking <%s> handler', topic)
            try:
                return handler(self, *args, **kwargs)
            except ApplicationError as e:
                raise e
            except Exception as e:
                self.app.logger.warning('Exception in <%s> handler thrown', topic, exc_info=True)
                raise e

        self.app.logger.debug('Subscribing to <%s> with %s', topic, handler)

        try:
            subscription = await ApplicationSession.subscribe(self, invoke, topic, options=options)
        except Error as exception:
            self.app.logger.error('Failed to subscribe to <%s> with error %s', topic, exception)
            raise exception

        self.app.logger.info('Subscribed to <%s> with id <%s>', topic, subscription.id)

        return subscription

    async def onJoin(self, details):
        self.router = details.authextra.get('router', None)
        #self.realm = details.realm
        self.id = details.session
        #self.authid = details.authid
        #self.authrole = details.authrole

        self.app.logger.info(
            'Session (%s) joined router <%s> on realm <%s> with authrole <%s> and authid <%s> using serializer <%s>',
            self.id,
            self.router,
            self.realm,
            self.authrole,
            self.authid,
            self._transport._serializer.SERIALIZER_ID
        )

        self.joined.set_result(True)

        await self.app.emit('connect', self)

        super().onJoin(details)

    def onLeave(self, details):
        self.app.logger.debug('Session left with reason <%s>', details.reason)

        return super().onLeave(details)

    async def onDisconnect(self, *args, **kwargs):
        self.app.logger.info('Session disconnected')

        self.disconnected.set_result(True)

        await self.app.emit('disconnect', self)

        ret = super().onDisconnect(*args, **kwargs)

        if self.app.config.dvmt_exit_on_session_disconnect:

            self.app.logger.info('Exiting after session disconnect')

            # shutdown/flush loggers here, because os._exit() will exit the
            # process without flushing buffers
            logging.shutdown()

            # use os._exit() instead of sys.exit() because latter works by
            # raising the SystemExit exception, and we'd rather exit
            # immediately ( eg, without potential of SystemExit being caught
            # and handled elsewhere in a way that will not exit the process )
            os._exit(0)

        return ret
